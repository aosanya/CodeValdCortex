// Work Items functionality
// Handles work items management

// Uses global functions: getCurrentAgencyId, showNotification, scrollToBottom, loadEntityList, etc., specificationAPI

// Work item editor state management
let workItemEditorState = {
    mode: 'add', // 'add' or 'edit'
    workItemKey: null,
    originalData: {}
};

// Load goals for the checkbox list
async function loadGoalsForSelection() {
    const agencyId = window.getCurrentAgencyId();
    if (!agencyId) return;

    try {
        const goals = await window.specificationAPI.getGoals();
        const container = document.getElementById('work-item-goals-editor');
        if (!container) return;

        // Clear existing content
        container.innerHTML = '';

        if (goals.length === 0) {
            container.innerHTML = '<p class="has-text-grey-light">No goals available. Create goals first.</p>';
            return;
        }

        // Add goals as checkboxes
        goals.forEach(goal => {
            const label = document.createElement('label');
            label.className = 'checkbox is-block mb-2';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = goal._key || goal.key;
            checkbox.className = 'mr-2';
            checkbox.dataset.goalKey = goal._key || goal.key;

            const text = document.createTextNode(` ${goal.code} - ${goal.description.substring(0, 60)}${goal.description.length > 60 ? '...' : ''}`);

            label.appendChild(checkbox);
            label.appendChild(text);
            container.appendChild(label);
        });
    } catch (error) {
    }
}

// Load work items list
window.loadWorkItems = function () {
    return loadEntityList('work-items', 'work-items-table-body', 4);
}

// Show work item editor
window.showWorkItemEditor = async function (mode, workItemKey = null) {
    workItemEditorState.mode = mode;
    workItemEditorState.workItemKey = workItemKey;

    showEntityEditor(
        mode,
        'work-item-editor-card',
        'work-items-list-card',
        'work-item-editor-title',
        'Add New Work Item',
        'Edit Work Item',
        'work-item-code-editor'
    );

    // Load available goals for the dropdown first
    await loadGoalsForSelection();

    if (mode === 'add') {
        clearWorkItemForm();
    } else if (mode === 'edit') {
        await loadWorkItemData(workItemKey);
    }
}

// Load work item data for editing
async function loadWorkItemData(workItemKey) {
    const agencyId = window.getCurrentAgencyId();
    if (!agencyId || !workItemKey) {
        return;
    }

    try {
        // Fetch work item data using specification API
        const workItems = await window.specificationAPI.getWorkItems();

        // Find work item by _key (UUID generated by backend)
        const workItem = workItems.find(wi => wi._key === workItemKey);

        if (workItem) {
            populateWorkItemForm(workItem);
            workItemEditorState.originalData = workItem;

            // Load linked goals for this work item
            await loadLinkedGoals(workItemKey);
        } else {
            window.showNotification('Work item not found', 'error');
        }
    } catch (error) {
        window.showNotification('Error loading work item data', 'error');
    }
}

// Load and select linked goals for a work item
async function loadLinkedGoals(workItemKey) {
    // In the unified specification model, work items have goal_keys array
    // Check the checkboxes for goals that are linked to this work item
    const container = document.getElementById('work-item-goals-editor');
    if (!container) return;

    const workItemData = workItemEditorState.originalData;
    if (!workItemData || !workItemData.goal_keys) return;

    // Get all checkboxes and check the ones that match goal_keys
    const checkboxes = container.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        const goalKey = checkbox.dataset.goalKey;
        if (workItemData.goal_keys.includes(goalKey)) {
            checkbox.checked = true;
        }
    });
}

// Populate form with work item data
function populateWorkItemForm(workItem) {
    const formData = {
        'work-item-code-editor': workItem.code || '',
        'work-item-title-editor': workItem.title || '',
        'work-item-description-editor': workItem.description || '',
        'work-item-deliverables-editor': workItem.deliverables ? workItem.deliverables.join('\n') : '',
        'work-item-tags-editor': workItem.tags ? workItem.tags.join(', ') : ''
    };
    populateForm(formData);
}

// Clear work item form
function clearWorkItemForm() {
    clearForm([
        'work-item-code-editor',
        'work-item-title-editor',
        'work-item-description-editor',
        'work-item-deliverables-editor',
        'work-item-tags-editor'
    ]);

    // Clear goals checkboxes
    const container = document.getElementById('work-item-goals-editor');
    if (container) {
        const checkboxes = container.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
    }

    workItemEditorState.originalData = {};
}

// Save work item from editor
window.saveWorkItemFromEditor = async function () {
    // Get form values
    const code = document.getElementById('work-item-code-editor')?.value.trim();
    const title = document.getElementById('work-item-title-editor')?.value.trim();
    const description = document.getElementById('work-item-description-editor')?.value.trim();
    const deliverables = document.getElementById('work-item-deliverables-editor')?.value
        .split('\n')
        .map(d => d.trim())
        .filter(d => d.length > 0);
    const tags = document.getElementById('work-item-tags-editor')?.value
        .split(',')
        .map(t => t.trim())
        .filter(t => t.length > 0);

    // Get selected goals from checkboxes
    const container = document.getElementById('work-item-goals-editor');
    const checkboxes = container ? container.querySelectorAll('input[type="checkbox"]:checked') : [];
    const selectedGoals = Array.from(checkboxes).map(cb => cb.value);

    // Validation
    if (!code) {
        window.showNotification('Please enter a work item code', 'warning');
        document.getElementById('work-item-code-editor')?.focus();
        return;
    }

    if (!title) {
        window.showNotification('Please enter a work item title', 'warning');
        document.getElementById('work-item-title-editor')?.focus();
        return;
    }

    if (!description) {
        window.showNotification('Please enter a work item description', 'warning');
        document.getElementById('work-item-description-editor')?.focus();
        return;
    }

    const data = {
        code,
        title,
        description,
        deliverables,
        goal_keys: selectedGoals,
        tags
    };

    // Save the work item using specification API
    try {
        const agencyId = window.getCurrentAgencyId();

        let savedWorkItem;
        if (workItemEditorState.mode === 'add') {
            savedWorkItem = await window.specificationAPI.addWorkItem(data);
        } else {
            savedWorkItem = await window.specificationAPI.updateWorkItem(workItemEditorState.workItemKey, data);
        }

        // No need to save goal links separately - they're part of the work item now

        window.showNotification('Work item saved successfully', 'success');
        cancelWorkItemEdit();
        loadWorkItems();
    } catch (error) {
        window.showNotification('Error saving work item', 'error');
    }
}

// Save goal links for a work item
// In the unified specification model, goal keys are stored directly in the work item
async function saveGoalLinks(workItemKey, selectedGoalKeys) {
    // Goal keys are now included in the work item data itself
    // This function is kept for compatibility but doesn't need to do anything
    // The goal_keys are saved as part of the work item in saveWorkItemFromEditor
    return Promise.resolve();
}

// Cancel work item edit
window.cancelWorkItemEdit = function () {
    cancelEntityEdit('work-item-editor-card', 'work-items-list-card', [
        'work-item-code-editor',
        'work-item-title-editor',
        'work-item-description-editor',
        'work-item-deliverables-editor',
        'work-item-tags-editor'
    ]);

    // Clear all navigational contexts when returning to work items list
    if (window.ContextManager) {
        window.ContextManager.clearNavigationalContexts();
    }

    // Reset state
    workItemEditorState = {
        mode: 'add',
        workItemKey: null,
        originalData: {}
    };
}

// Delete work item
window.deleteWorkItem = function (workItemKey) {
    deleteEntity('work-items', workItemKey, 'this work item', loadWorkItems);
}

// Filter work items
window.filterWorkItems = function () {
    const searchInput = document.getElementById('work-item-search')?.value.toLowerCase() || '';
    const typeFilter = document.getElementById('filter-type')?.value || '';
    const tbody = document.getElementById('work-items-tbody');
    if (!tbody) return;

    const rows = tbody.querySelectorAll('.table-item');

    rows.forEach(row => {
        const key = row.dataset.itemKey || '';
        const title = row.querySelector('.has-text-weight-semibold')?.textContent.toLowerCase() || '';

        const matchesSearch = !searchInput || key.toLowerCase().includes(searchInput) || title.includes(searchInput);

        if (matchesSearch) {
            row.style.display = '';
        } else {
            row.style.display = 'none';
        }
    });
}

// AI Work Item Operations
window.processAIWorkItemOperation = async function (operations) {
    const agencyId = window.getCurrentAgencyId();
    if (!agencyId) {
        window.showNotification('Error: No agency selected', 'error');
        return;
    }

    // Validate operations array
    if (!operations || operations.length === 0) {
        window.showNotification('Error: No operation specified', 'error');
        return;
    }

    // For enhance/consolidate operations, get selected work items
    let selectedWorkItemKeys = [];
    if (operations.includes('enhance') || operations.includes('consolidate')) {
        selectedWorkItemKeys = getSelectedWorkItemKeys();
        if (selectedWorkItemKeys.length === 0) {
            window.showNotification('Please select work items first', 'warning');
            return;
        }
    }

    let statusMessage = 'AI is processing your request...';
    if (operations.length === 1) {
        switch (operations[0]) {
            case 'create':
                statusMessage = 'AI is generating work items from your goals...';
                break;
            case 'enhance':
                statusMessage = `AI is enhancing ${selectedWorkItemKeys.length} work item(s)...`;
                break;
            case 'consolidate':
                statusMessage = `AI is consolidating ${selectedWorkItemKeys.length} work item(s)...`;
                break;
        }
    } else if (operations.length > 1) {
        statusMessage = `AI is performing ${operations.length} operations on your work items...`;
    }

    // Show AI processing status in the chat area
    if (window.showAIProcessStatus) {
        window.showAIProcessStatus(statusMessage);
    }

    try {
        const requestBody = { operations };

        // Include selected work item keys if applicable
        if (selectedWorkItemKeys.length > 0) {
            requestBody.work_item_keys = selectedWorkItemKeys;
        }

        const response = await fetch(`/api/v1/agencies/${agencyId}/work-items/ai-process`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`Failed to process AI work item operations: ${response.statusText}`);
        }

        const data = await response.json();

        // Update status to show we're processing results
        if (window.showAIProcessStatus) {
            window.showAIProcessStatus('Processing results and updating work items...');
        }

        // Reload work items to show updates
        await loadWorkItems();

        // After work items are reloaded, refresh chat messages so AI explanation appears in the chat
        try {
            const chatContainer = document.getElementById('chat-messages');
            if (chatContainer) {
                const chatResp = await fetch(`/agencies/${agencyId}/chat-messages`);
                if (chatResp.ok) {
                    const chatHtml = await chatResp.text();
                    chatContainer.innerHTML = chatHtml;
                    // Scroll to bottom to show latest assistant message
                    try { scrollToBottom(chatContainer); } catch (e) { /* ignore */ }
                }
            }
        } catch (err) {
        }

        // Hide AI processing status after work items and chat are updated
        if (window.hideAIProcessStatus) {
            window.hideAIProcessStatus();
        }

        // Show success message with results
        if (data.created_count > 0) {
            window.showNotification(`Successfully created ${data.created_count} work items!`, 'success');
        } else if (data.enhanced_count > 0) {
            window.showNotification(`Successfully enhanced ${data.enhanced_count} work items!`, 'success');
        } else if (data.results && data.results.consolidate_success) {
            window.showNotification(data.results.consolidate_success, 'success');
        } else {
            window.showNotification('AI operations completed!', 'success');
        }

    } catch (error) {
        // Hide AI processing status
        if (window.hideAIProcessStatus) {
            window.hideAIProcessStatus();
        }

        window.showNotification(`AI processing failed: ${error.message}`, 'danger');
    }
}

// Get selected work item keys from checkboxes
function getSelectedWorkItemKeys() {
    const checkboxes = document.querySelectorAll('.work-item-checkbox:checked');
    return Array.from(checkboxes).map(cb => cb.dataset.workItemKey);
}

// Update selection buttons based on checkbox state
window.updateWorkItemSelectionButtons = function () {
    const selectedKeys = getSelectedWorkItemKeys();
    const hasSelection = selectedKeys.length > 0;

    // Update "Select All" checkbox state
    const selectAllCheckbox = document.getElementById('select-all-work-items');
    const allCheckboxes = document.querySelectorAll('.work-item-checkbox');
    if (selectAllCheckbox && allCheckboxes.length > 0) {
        const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
        const someChecked = Array.from(allCheckboxes).some(cb => cb.checked);
        selectAllCheckbox.checked = allChecked;
        selectAllCheckbox.indeterminate = someChecked && !allChecked;
    }

    // Enable/disable Enhance and Consolidate buttons
    const enhanceBtn = document.getElementById('ai-enhance-work-items-btn');
    const consolidateBtn = document.getElementById('ai-consolidate-work-items-btn');

    if (enhanceBtn) {
        if (hasSelection) {
            enhanceBtn.disabled = false;
            enhanceBtn.classList.remove('is-static');
            enhanceBtn.title = `Enhance ${selectedKeys.length} selected work item(s)`;
        } else {
            enhanceBtn.disabled = true;
            enhanceBtn.classList.add('is-static');
            enhanceBtn.title = 'Select work items to enhance';
        }
    }

    if (consolidateBtn) {
        if (hasSelection) {
            consolidateBtn.disabled = false;
            consolidateBtn.classList.remove('is-static');
            consolidateBtn.title = `Consolidate ${selectedKeys.length} selected work item(s)`;
        } else {
            consolidateBtn.disabled = true;
            consolidateBtn.classList.add('is-static');
            consolidateBtn.title = 'Select work items to consolidate';
        }
    }

    // Update selection count display
    updateWorkItemSelectionCount(selectedKeys.length);
}

// Toggle all work item checkboxes
function toggleAllWorkItems(checked) {
    const checkboxes = document.querySelectorAll('.work-item-checkbox');
    checkboxes.forEach(cb => {
        cb.checked = checked;
    });
    updateWorkItemSelectionButtons();
}

// Update selection count display
function updateWorkItemSelectionCount(count) {
    const countDisplay = document.getElementById('work-item-selection-count');

    if (countDisplay) {
        if (count > 0) {
            countDisplay.textContent = `${count} selected`;
            countDisplay.style.display = 'inline-block';
        } else {
            countDisplay.style.display = 'none';
        }
    }
}

// Initialize button states on page load
document.addEventListener('DOMContentLoaded', function () {
    updateWorkItemSelectionButtons();
});

// Make functions available globally
window.loadWorkItems = loadWorkItems;
window.showWorkItemEditor = showWorkItemEditor;
window.saveWorkItemFromEditor = saveWorkItemFromEditor;
window.cancelWorkItemEdit = cancelWorkItemEdit;
window.deleteWorkItem = deleteWorkItem;
window.filterWorkItems = filterWorkItems;
window.processAIWorkItemOperation = processAIWorkItemOperation;
window.getSelectedWorkItemKeys = getSelectedWorkItemKeys;
window.updateWorkItemSelectionButtons = updateWorkItemSelectionButtons;
window.toggleAllWorkItems = toggleAllWorkItems;
