# Examples & Use Cases

Real-world examples of work item execution across different work types.

## Example 1: Documentation Update

### Scenario

Update architecture documentation to reflect new workflow design.

### Gitea Issue

```markdown
Title: Update architecture documentation with workflow design
Labels: documentation, work-item, P1

Description:
The architecture documentation needs to be updated to include our new 
GitOps-based workflow system. Please update the following:

1. Add workflow architecture diagram
2. Explain work item execution model
3. Document Gitea integration
4. Add examples of automated work items

File: docs/architecture/workflow.md
```

### Execution Flow

```
1. Webhook received (issue #42 opened)
   ↓
2. Work item created in ArangoDB
   - Type: document
   - Priority: P1
   - Status: pending
   ↓
3. Goroutine spawned
   ↓
4. Work type classification
   - Labels analyzed: ["documentation", "work-item"]
   - Classified as: document
   ↓
5. LLM content generation
   - Load existing: docs/architecture/workflow.md
   - Prompt: Update with workflow design
   - Generate: Updated markdown content
   ↓
6. Git operations
   - Create branch: issue-42-update-architecture
   - Commit: "docs: update architecture with workflow design"
   - Push to Gitea
   ↓
7. Create merge request
   - Title: "[Work Item] Update architecture documentation"
   - Body: "Closes #42"
   - Labels: ["documentation", "automated"]
   ↓
8. Auto-merge (docs don't require review)
   - Merge style: squash
   - Delete branch: yes
   ↓
9. Close issue #42
   ↓
10. Store in ArangoDB
    - Work item status: completed
    - Commit linked to work item
    - Update knowledge graph
```

**Time**: ~30 seconds  
**LLM Tokens**: ~2,000 (prompt) + ~3,000 (completion) = 5,000 total  
**Cost**: ~$0.10

### Generated Commit

```
commit e83c5163316f89bfbde7d9ab23ca2e25604af290
Author: LLM Agent <llm-agent@codevaldcortex.ai>
Date:   Thu Nov 7 10:30:00 2025 +0000

    docs: update architecture with workflow design
    
    - Add workflow architecture diagram
    - Explain work item execution model
    - Document Gitea integration
    - Add examples of automated work items
    
    Closes #42
    
    Generated by Work Item WI-CORP-DOC-20251107-A3F9B2
```

## Example 2: Feature Implementation

### Scenario

Implement user authentication API endpoint with tests.

### Gitea Issue

```markdown
Title: Implement user authentication API endpoint
Labels: feature, backend, work-item, P0

Description:
Create a REST API endpoint for user authentication with the following requirements:

## Endpoint
POST /api/v1/auth/login

## Request Body
{
  "email": "user@example.com",
  "password": "password123"
}

## Response
Success (200):
{
  "token": "jwt-token-here",
  "user": {"id": 1, "email": "user@example.com", "name": "John Doe"}
}

Error (401):
{
  "error": "Invalid credentials"
}

## Requirements
- Use JWT for tokens
- Hash passwords with bcrypt
- Validate email format
- Return token valid for 24 hours
- Include comprehensive tests
- Follow existing project structure
```

### Execution Flow

```
1. Webhook received (issue #87 opened)
   ↓
2. Work item created
   - Type: software
   - Priority: P0
   - Status: pending
   ↓
3. LLM creates implementation plan
   {
     "files": [
       {
         "path": "internal/api/handlers/auth_handler.go",
         "action": "create",
         "description": "Authentication handler with login endpoint"
       },
       {
         "path": "internal/api/middleware/jwt.go",
         "action": "create",
         "description": "JWT token generation and validation"
       },
       {
         "path": "internal/models/user.go",
         "action": "modify",
         "description": "Add authentication methods"
       }
     ],
     "tests": [
       {
         "path": "internal/api/handlers/auth_handler_test.go",
         "description": "Unit tests for authentication"
       }
     ],
     "dependencies": [
       "go get github.com/golang-jwt/jwt/v5",
       "go get golang.org/x/crypto/bcrypt"
     ]
   }
   ↓
4. LLM generates code for each file
   - auth_handler.go: Login handler implementation
   - jwt.go: JWT middleware
   - user.go: Updated with auth methods
   - auth_handler_test.go: Comprehensive tests
   ↓
5. Build dependency graph
   - auth_handler.go → jwt.go
   - auth_handler.go → user.go
   - Store in code_graph
   ↓
6. Git operations
   - Branch: issue-87-user-auth
   - Commit all files with proper messages
   - Push to Gitea
   ↓
7. Create merge request
   - Title: "[Work Item] Implement user authentication"
   - Body: Detailed description + "Closes #87"
   ↓
8. CI pipeline runs
   - go vet: PASS
   - go test: PASS (100% coverage)
   - golangci-lint: PASS
   ↓
9. Auto-merge (CI passed, trusted automation)
   - Merge style: squash
   ↓
10. Close issue #87
```

**Time**: ~2-3 minutes  
**LLM Tokens**: ~15,000 total  
**Cost**: ~$0.30  
**Files Created**: 4 (3 implementation + 1 test)

### Generated Code Sample

```go
// internal/api/handlers/auth_handler.go
package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "codevaldcortex/internal/models"
    "codevaldcortex/internal/api/middleware"
)

type AuthHandler struct {
    userRepo *models.UserRepository
    jwtKey   []byte
}

func NewAuthHandler(userRepo *models.UserRepository, jwtKey []byte) *AuthHandler {
    return &AuthHandler{
        userRepo: userRepo,
        jwtKey:   jwtKey,
    }
}

// Login godoc
// @Summary User login
// @Description Authenticate user and return JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Login credentials"
// @Success 200 {object} LoginResponse
// @Failure 401 {object} ErrorResponse
// @Router /api/v1/auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request"})
        return
    }
    
    // Validate email
    if !isValidEmail(req.Email) {
        c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid email format"})
        return
    }
    
    // Find user
    user, err := h.userRepo.FindByEmail(req.Email)
    if err != nil {
        c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid credentials"})
        return
    }
    
    // Verify password
    if err := user.ComparePassword(req.Password); err != nil {
        c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid credentials"})
        return
    }
    
    // Generate JWT
    token, err := middleware.GenerateJWT(user.ID, h.jwtKey, 24*time.Hour)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Token generation failed"})
        return
    }
    
    c.JSON(http.StatusOK, LoginResponse{
        Token: token,
        User:  user.ToPublic(),
    })
}
```

## Example 3: Impact Analysis

### Scenario

Analyze what breaks if we modify the user service.

### Query

```go
// Which files will be affected if we change user_service.go?
result := repo.AnalyzeChangeImpact("git_objects/user_service_hash")
```

### Graph Traversal

```
user_service.go
├── auth_handler.go (direct dependency)
│   ├── api_router.go
│   └── middleware/auth.go
├── profile_handler.go (direct dependency)
│   └── api_router.go
└── admin_handler.go (direct dependency)
    └── api_router.go

Impact Summary:
- Direct dependents: 3 files
- Transitive dependents: 5 files  
- Total affected: 8 files
- Test files: 4 files
- Impact score: 85/100 (HIGH)
```

### Result

```json
{
  "file": "internal/services/user_service.go",
  "impact_score": 85,
  "direct_dependents": 3,
  "transitive_dependents": 5,
  "total_affected": 8,
  "affected_files": [
    "internal/api/handlers/auth_handler.go",
    "internal/api/handlers/profile_handler.go",
    "internal/api/handlers/admin_handler.go",
    "internal/api/router.go",
    "internal/api/middleware/auth.go"
  ],
  "test_files": [
    "internal/services/user_service_test.go",
    "internal/api/handlers/auth_handler_test.go",
    "internal/api/handlers/profile_handler_test.go",
    "internal/api/handlers/admin_handler_test.go"
  ],
  "recommendation": {
    "require_reviews": 2,
    "require_ci": true,
    "auto_merge": false,
    "reason": "High impact change affecting 8 files"
  }
}
```

### Automatic Action

Based on impact score, system automatically:
1. Requires 2 code reviews
2. Disables auto-merge
3. Requires all CI checks to pass
4. Assigns expert reviewers from knowledge graph

## Example 4: Find Code Expert

### Scenario

Need reviewer for payment processing changes.

### Query

```go
experts := repo.FindCodeExpert("git_objects/payment_processor_hash")
```

### Knowledge Graph Traversal

```
payment_processor.go
└─[INBOUND via agent_code_expertise]─┐
                                      ├── agent: alice@example.com
                                      │   - expertise: 0.92
                                      │   - commits: 47
                                      │   - last_touch: 2 days ago
                                      │
                                      ├── agent: bob@example.com
                                      │   - expertise: 0.68
                                      │   - commits: 15
                                      │   - last_touch: 1 week ago
                                      │
                                      └── agent: charlie@example.com
                                          - expertise: 0.45
                                          - commits: 8
                                          - last_touch: 3 weeks ago
```

### Result

```json
{
  "file": "internal/payment/processor.go",
  "experts": [
    {
      "agent": "alice@example.com",
      "name": "Alice Johnson",
      "expertise": 0.92,
      "commits": 47,
      "last_contribution": "2025-11-05T14:30:00Z",
      "recency_score": 0.95,
      "contribution_score": 96.7
    },
    {
      "agent": "bob@example.com",
      "name": "Bob Smith",
      "expertise": 0.68,
      "commits": 15,
      "last_contribution": "2025-10-31T09:15:00Z",
      "recency_score": 0.81,
      "contribution_score": 69.5
    }
  ],
  "recommendation": "Assign alice@example.com as primary reviewer"
}
```

### Automatic Action

System automatically:
1. Assigns Alice as primary reviewer
2. Adds Bob as optional reviewer
3. Sets review deadline based on priority
4. Notifies via Gitea mention

## Example 5: Circular Dependency Detection

### Scenario

Detect and report circular dependencies in codebase.

### Analysis Work Item

Created automatically by scheduled job:

```markdown
Title: Weekly code quality analysis
Labels: analysis, work-item, automated

Description:
Perform automated code quality analysis:
- Detect circular dependencies
- Find files with high churn
- Identify under-tested modules
- Report code complexity metrics
```

### Graph Query

```aql
FOR file IN git_objects
    FILTER file.type == "blob"
    FILTER file.language == "go"
    
    LET cycles = (
        FOR v, e, p IN 2..10 OUTBOUND file._id
            GRAPH 'code_graph'
            FILTER v._id == file._id
            LIMIT 1
            RETURN p.vertices[* RETURN CURRENT.path]
    )
    
    FILTER LENGTH(cycles) > 0
    RETURN {
        file: file.path,
        cycle: cycles[0]
    }
```

### Detected Issues

```json
[
  {
    "issue": "Circular dependency detected",
    "severity": "high",
    "cycle": [
      "internal/api/handler.go",
      "internal/service/user.go",
      "internal/api/middleware.go",
      "internal/api/handler.go"
    ],
    "recommendation": "Break circular dependency by extracting interface"
  },
  {
    "issue": "Circular dependency detected",
    "severity": "medium",
    "cycle": [
      "pkg/auth/service.go",
      "pkg/user/repository.go",
      "pkg/auth/service.go"
    ],
    "recommendation": "Move shared types to separate package"
  }
]
```

### Generated Report

LLM generates comprehensive Markdown report stored in git:

```markdown
# Code Quality Analysis Report
Date: November 7, 2025

## Executive Summary
- Circular dependencies detected: 2
- High churn files: 5
- Under-tested modules: 3

## Circular Dependencies

### 1. API Handler → User Service → Middleware → Handler
**Severity**: High  
**Impact**: 8 files affected

**Cycle**:
```
internal/api/handler.go 
  → internal/service/user.go 
  → internal/api/middleware.go 
  → internal/api/handler.go
```

**Recommendation**:
Extract authentication interface:
```go
// pkg/auth/interface.go
type Authenticator interface {
    Authenticate(ctx context.Context, token string) (*User, error)
}
```

...
```

### Automatic Actions

1. Create Gitea issues for each detected problem
2. Assign to relevant code experts (from knowledge graph)
3. Set priority based on severity
4. Link to affected files
5. Suggest fixes

## Example 6: Batch Processing

### Scenario

Process 50 documentation update issues overnight.

### Batch Executor

```go
func (e *BatchExecutor) ProcessPendingIssues() error {
    // Get all pending work-item issues
    issues, err := e.gitea.ListIssues(gitea.ListIssueOption{
        State:  "open",
        Labels: []string{"work-item"},
    })
    
    // Filter only pending
    var pending []*gitea.Issue
    for _, issue := range issues {
        if !e.isProcessed(issue.Index) {
            pending = append(pending, issue)
        }
    }
    
    log.Printf("Processing %d pending issues", len(pending))
    
    // Process in parallel (max 10 concurrent)
    semaphore := make(chan struct{}, 10)
    var wg sync.WaitGroup
    
    for _, issue := range pending {
        wg.Add(1)
        go func(iss *gitea.Issue) {
            defer wg.Done()
            semaphore <- struct{}{}
            defer func() { <-semaphore }()
            
            if err := e.executor.Execute(context.Background(), iss); err != nil {
                log.Printf("Failed to process issue #%d: %v", iss.Index, err)
            }
        }(issue)
    }
    
    wg.Wait()
    return nil
}
```

**Results**:
- 50 issues processed
- 45 succeeded, 5 failed
- Total time: ~25 minutes
- Average time per issue: 30 seconds
- Total LLM cost: ~$4.50

---

**See Also**:
- [Work Item Types](./work-item-types.md) - Work type details
- [Graph Queries](./graph-queries.md) - Query patterns
- [LLM Integration](./llm-integration.md) - Content generation
